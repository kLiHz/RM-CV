# C语言宏定义

预处理是在编译之前的处理，C语言预处理器执行宏替换、条件编译和文件包含。通常采用以“#”为行首的提示。下面是C语言预处理的应用场合：

## **1. 三字母词（Trigraph Sequences）**

C源程序的字符集被包含在7位的ASCII字符集中，但是它是ISO 646-1983 Invariant Code Set的超集。为了让程序可以在缩减集(reduced set)中呈现出来，下面的三字母词会被替换成相应的单字符.

| 三字母词 | 单字符 |
| :---: |:---:|
| `??=` | `#` |
| `??/` | `\` |
| `??'` | `^` |
| `??(` | `[` |
| `??)` | `]` |
| `??!` | `|` |
| `??<` | `{` |
| `??>` | `}` |
| `??-` | `~` |

替换发生在任何其他处理之前。

例如：如果你尝试打印字符串`"what??!"`

```c++
printf("what??!\n");
```

会得到字符串`"what|"`。

如果你这样注释代码，结果会让你意外：

代码如下:

```cpp
// Will the next line be executed?????????????/
a++;
```

`a++`并不会执行。（前提是你知道`\`的作用）

**注意**：由于编译器对ANSI C的支持不一样，有些编译器会把三字母词当普通字符处理，你需要给编译选项加上“`-trigraphs`”

## **2. 行拼接**

以反斜杠"`\`"结尾的行会把该行和下一行拼接成一行(预处理器做的工作就是把该反斜杠"`\`"和接着的换行字符'`\n`'删除)。（'`\`'称为续行符）

例如你可以这样写

```cpp
/\
* is a legal comment. *\
/
```

## **3. 宏定义和展开**

### **a) 简单宏替换**

简单宏替换使程序中能用一个标识符来表示一个单词串，指令形式为：

```cpp
#define 标识符 单词串
```

**标识符**（称为**宏名**）被定义为后面的**单词串**；单词串（简称串）是任意以换行结束的用于替换程序中该标识符的正文。如果串太长需要写成多行，则除了最后一行外每一行末尾都要有一个续行符（即添加一个“`\`”后回车）。

宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误。

注意：字符串常数中出现的与宏名相同的字符串不在替换之列。例如：

```cpp
#define YES 1
printf("YES");    // 输出 YES，而不是1
```

宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用`#undef`命令。



### **b) 带参数的宏替换**

预处理指令的形式为：

```cpp
#define 宏名(参数列表)  单词串
```

“`宏名(标识符,标识符,...,标识符)`”是被定义的宏，`()`中的标识符是宏的形式参数；宏名与其后的`()`之间不能有空白符。

例如：

```cpp
#define max(a,b) ((a)>(b)? (a): (b))
```

在编译预处理时，将源程序中所有宏名替换成字符串，并且将 **字符串中的参数** 用 宏名右边**参数列表** 中的参数替换。

#### 操作符`#`和`##`

操作符`#`把其后的串变成双引号包围的串；

操作符`##`把两个标志符拼在一起，形成一个新的标识符

```cpp
#define str(expr)　　　　#expr
#define cat(x,y)    　　x ## y

int ab=12;
printf(str(hello world!));　　　　　　// 会被替换成 printf("hello world!");
printf("ab=%d\n", cat(a,b));        // 会被替换成 printf("ab=%d\n", ab);  输出 ab=12
```

#### **宏替换时的顺序**　

```cpp
#include <stdio.h>
#define f(a,b)　　a##b
#define g(a)　　　#a
#define h(a)　　　g(a)

int main()
{
    printf("%s\n", h(f(1,2)));
    printf("%s\n", g(f(1,2)));
    return 0;
}
```

输出结果是`12`和`f(1,2)`。为什么会这样呢，宏的解开不像函数，由里到外。

（1）在`""`内的宏名或宏参数名不被替换

（2）宏替换顺序：一个带参数的宏内部调用另一个宏，参数也是一个宏，则先替换外层的宏，再替换外层宏的参数，最后替换内层宏。

知道这些规则对于出现上面的结果就不难理解了。



温馨提示：在写带参数的宏替换指令时，推荐的做法时将单词串中的**每一个参数**都用`()`括起来，**整个表达式**也要用`()`括起来；否则，替换结果可能不是你想要的，例如：

```cpp
#define sqr(x)    x * x
// 如果程序中的宏的引用形式为：
sqr(3.0+1.0);   // 那么经预处理后会被替换为 3.0 + 1.0 * 3.0 + 1.0
```

结果与你的原意(3.0+1.0)*(3.0+1.0)不等价

```cpp
#define sqr(x)    ((x) * (x))
sqr(3.0+1.0); 
```



但正所谓，假的总是假的，即使宏多么像函数，它依旧不是函数，如果真的把它当成函数，你会在某些时候错的摸不着头脑。

还是一个经典的例子，比较大小

```cpp
#define CMP(x, y) (x > y ? x : y)
...
int x = 100, y = 200;
int result = CMP(x, y++);
printf("x = %d, y = %d, result = %d\n", x, y, result);
```

执行这部分代码，会输出什么呢？ 答案是，不知道！至少result的值我们无法确定，我们将代码展开得到

```cpp
int result = (x > y++ ? x : y++);
```

看起来似乎就是y递增两次，最后result肯定是200。真是如此？C语言标准对于一个确定的程序语句中，一个对象只能被修改一次，超过一次那么结果是未定的，由编译器决定。除了三目操作符`?:`外，还有`&&`, `||`或是`,`之中，或者函数参数调用，`switch`控制表达式，`for`里的控制语句。

由此可看出，宏的使用也是有风险的，所以虽然宏强大，但是依旧不能滥用。







### c) 取消宏定义

```cpp
#undef 标识符
```

会使宏名标识符失去定义。如果`#undef` 一个没有定义过的标识符 也不会引发错误。



### d) 可变参数宏

https://www.cnblogs.com/wanghetao/p/4492334.html



## **4. 文件包含**　　



```cpp
#include <filename>   // 编译器将在系统的头文件目录中搜索
#include "filename"   // 编译器首先查找当前工作目录或源代码目录，然后再在标准位置查找
```

### 头文件保护

避免出现多次声明的问题，要确保头文件只被包含一次。

头文件中不能包含函数定义，虽然头文件保护过后只会被包含/复制一次，但当一个头文件**被多个源文件包含**时，在最后的链接步骤就会出现重复定义的错误。

## **5. 条件编译**

条件编译指令格式如下：

```cpp
if-line 正文 
[#elif 常量表达式 正文]
...
[#else 正文]
#endif
```

`if-line`为下面中的任意一种形式：

- `#if` 常量表达式

- `#ifdef` 标识符

- `#ifndef` 标识符

`defined`操作符用来判断标识符是否定义过。形式如下：`defined identifier`或`defined (identifier)`

下面左边的写法等价于右边的写法：

| 写法 A               | 写法 B                     |
| -------------------- | -------------------------- |
| `#ifdef identifier`  | `#if defined identifier`   |
| `#ifndef identifier` | `#if ! defined identifier` |

### **C和C++混合编程的情况**

经常能在源代码中看见 `extern "C"` 这样的身影，这是做什么的？

这是为了混合编程而设计的，常出现在 C++的源代码中，目的是为了让 C++能够成功的调用 C 的标准或非标准函数。

```cpp
#if defined(__cplusplus) || defined(_cplusplus)
    extern "C" {
#endif
 
    /**主体代码**/
 
#if defined(__cplusplus) || defined(_cplusplus)
    }
#endif
```

这样就能在C++中调用C的代码了。

在 C 中调用 C++ 的函数需要注意，不能使用重载功能，否则会失败，原因详见C++对于重载函数的实现



## **6. 行控制**



行控制指令有下列两种形式



**（1）#line n "filename"**



**（2）#line n**



行控制预处理功能为其他产生C源程序的预处理程序（例如数据库系统中的宿主C预编译程序）在跟踪被处理程序（例如被宿主C预编译程序处理的扩展名为.pc的预编译源程序）的行号时提供方便，便于最终用户的源程序查错和该错。它会使编译器相信n（十进制正整数）为下一个源程序行的行号，“filename”会被当作当前文件名。



## **7. 生成错误**



`#error error_messageopt`



　　让编译器输出错误信息error_message



## **8. Pragmas**



`#pragma token-sequenceopt`



`#pragma`是编译程序实现时定义的指令，它允许由此向编译程序传入各种指令。例如，一个编译程序可能具有支持跟踪程序执行的选项，此时可以用`#pragma`语句选择该功能。编译程序忽略其不支持的`#pragma`选项。`#pragma`提高C源程序对编译程序的可移植性。



## **9. 空指令**



形如

```cpp
#
```

没有任何作用



## **10. 预定义宏**

C语言规范了5个固有的预定义宏，他们分别是

|宏名|说明|
|---|---|
|`__LINE__`|　　当前行号，十进制常量  |
|`__FILE__`|　　正在编译的文件的文件名，字符串常量  |
|`__DATE__`|　　编译的日期字符串，形如`"MMM DD YYYY"`的字符串常量  |
|`__TIME__`|　　编译的时间字符串，形如`"HH:MM:SS"`的字符串常量  |
|`__STDC__`|　　如果`__STDC__`的内容是十进制常数1，则表示编译程序的实现符合标准C  |

### 是否遵循ISO标准

如果你想检验你现在使用的编译器是否遵循ISO标准，用它，如果是他的值为1。

```cpp
printf("%d\n", __STDC__);
```

### 当前行及当前文件

```cpp
#include <stdio.h>

#define DEPAKEGE(X) #X
#define PAKEGE(X) DEPAKEGE(X)
#define WHERE_AM_I "Line: " PAKEGE(__LINE__) " in " __FILE__

int main() {
    puts(WHERE_AM_I);
}
```





---

[C语言预处理命令详解 - cnblogs.com](https://www.cnblogs.com/clover-toeic/p/3851102.html)

